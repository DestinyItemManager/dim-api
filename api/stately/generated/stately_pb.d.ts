// @generated by Stately. DO NOT EDIT.
/* eslint-disable */

import type { Message as ProtobufESMessage } from '@bufbuild/protobuf';
import type { GenEnum, GenFile, GenMessage } from '@bufbuild/protobuf/codegenv1';

export declare const file_stately: GenFile;

/**
 * These items can be accessed via the following key paths:
 *   * /apps-:partition/app-:id
 */
export declare type ApiApp = ProtobufESMessage<'stately.generated.stately.ApiApp'> & {
  /**
   * A short ID that uniquely identifies the app.
   */
  id: string;
  /**
   * Apps must share their Bungie.net API key with us.
   */
  bungieApiKey: string;
  /**
   * Apps also get a generated API key for accessing DIM APIs that don't involve user data.
   */
  dimApiKey: string;
  /**
   * The origin used to allow CORS for this app. Only requests from this origin are allowed.
   */
  origin: string;
  /**
   * This isn't a "real" field but StatelyDB won't allow a group without an ID.
   */
  partition: bigint;
};

/**
 * Describes the message stately.generated.ApiApp.
 * Use `create(ApiAppSchema)` to create a new message.
 */
export declare const ApiAppSchema: GenMessage<ApiApp>;

/**
 * These items can be accessed via the following key paths:
 *   * /gs-:stage
 */
export declare type GlobalSettings =
  ProtobufESMessage<'stately.generated.stately.GlobalSettings'> & {
    stage: string;
    /**
     * Whether the API is enabled or not.
     */
    dimApiEnabled: boolean;
    /**
     * Don't allow refresh more often than this many seconds.
     */
    destinyProfileMinimumRefreshInterval: bigint;
    /**
     * Time in seconds to refresh the profile when autoRefresh is true.
     */
    destinyProfileRefreshInterval: bigint;
    /**
     * Whether to refresh profile automatically.
     */
    autoRefresh: boolean;
    /**
     * Whether to refresh profile when the page becomes visible after being in the background.
     */
    refreshProfileOnVisible: boolean;
    /**
     * Don't automatically refresh DIM profile info more often than this many seconds.
     */
    dimProfileMinimumRefreshInterval: bigint;
    /**
     * Display an issue banner, if there is one.
     */
    showIssueBanner: boolean;
    lastUpdated: bigint;
  };

/**
 * Describes the message stately.generated.GlobalSettings.
 * Use `create(GlobalSettingsSchema)` to create a new message.
 */
export declare const GlobalSettingsSchema: GenMessage<GlobalSettings>;

/**
 * Any extra info added by the user to individual items - tags, notes, etc.
 *
 * These items can be accessed via the following key paths:
 *   * /p-:profileId/d-:destinyVersion/ia-:id
 */
export declare type ItemAnnotation =
  ProtobufESMessage<'stately.generated.stately.ItemAnnotation'> & {
    profileId: bigint;
    destinyVersion: number;
    tag: TagValue;
    notes: string;
    /**
     * The item instance ID for an individual item
     */
    id: bigint;
    /**
     * UTC epoch seconds timestamp of when the item was crafted. Used to
     * match up items that have changed instance ID from being reshaped since they
     * were tagged.
     */
    craftedDate: bigint;
  };

/**
 * Describes the message stately.generated.ItemAnnotation.
 * Use `create(ItemAnnotationSchema)` to create a new message.
 */
export declare const ItemAnnotationSchema: GenMessage<ItemAnnotation>;

/**
 * Any extra info added by the user to item hashes (shaders and mods)
 *
 * These items can be accessed via the following key paths:
 *   * /p-:profileId/d-:destinyVersion/iht-:hash
 */
export declare type ItemHashTag = ProtobufESMessage<'stately.generated.stately.ItemHashTag'> & {
  profileId: bigint;
  destinyVersion: number;
  tag: TagValue;
  notes: string;
  /**
   * The inventory item hash for an item
   */
  hash: number;
};

/**
 * Describes the message stately.generated.ItemHashTag.
 * Use `create(ItemHashTagSchema)` to create a new message.
 */
export declare const ItemHashTagSchema: GenMessage<ItemHashTag>;

/**
 * These items can be accessed via the following key paths:
 *   * /p-:profileId/d-:destinyVersion/loadout-:id
 */
export declare type Loadout = ProtobufESMessage<'stately.generated.stately.Loadout'> & {
  /**
   * A globally unique (UUID) identifier for the loadout. Chosen by the client, not autogenerated by the DB.
   */
  id: Uint8Array;
  name: string;
  notes: string;
  classType: DestinyClass;
  equipped: LoadoutItem[];
  unequipped: LoadoutItem[];
  parameters?: LoadoutParameters;
  createdAt: bigint;
  lastUpdatedAt: bigint;
  destinyVersion: number;
  profileId: bigint;
};

/**
 * Describes the message stately.generated.Loadout.
 * Use `create(LoadoutSchema)` to create a new message.
 */
export declare const LoadoutSchema: GenMessage<Loadout>;

/**
 * These items can be accessed via the following key paths:
 *   * /loadoutShare-:id
 */
export declare type LoadoutShare = ProtobufESMessage<'stately.generated.stately.LoadoutShare'> & {
  /**
   * A globally unique short random string to be used when sharing the loadout, but which is hard to guess.
   * This is essentially 35 random bits encoded via base32 into a 7-character string. It'd be neat if we could
   * support that, with a parameterizable string length.
   */
  id: string;
  name: string;
  notes: string;
  classType: DestinyClass;
  equipped: LoadoutItem[];
  unequipped: LoadoutItem[];
  parameters?: LoadoutParameters;
  createdAt: bigint;
  lastUpdatedAt: bigint;
  destinyVersion: number;
  profileId: bigint;
  /**
   * A count that increases on each view. Not the most efficient way to deal
   * with this - maybe that should be a child document.
   */
  viewCount: number;
};

/**
 * Describes the message stately.generated.LoadoutShare.
 * Use `create(LoadoutShareSchema)` to create a new message.
 */
export declare const LoadoutShareSchema: GenMessage<LoadoutShare>;

/**
 * A search query. This can either be from history (recent searches), pinned (saved searches), or suggested.
 *
 * These items can be accessed via the following key paths:
 *   * /p-:profileId/d-:destinyVersion/search-:qhash
 */
export declare type Search = ProtobufESMessage<'stately.generated.stately.Search'> & {
  /**
   * The full search query. These are
   */
  query: string;
  /**
   * A zero usage count means this is a suggested/preloaded search.
   */
  usageCount: number;
  /**
   * Has this search been saved/favorite'd/pinned by the user?
   */
  saved: boolean;
  /**
   * The last time this was used, as a unix millisecond timestamp. We don't
   * use fromMetadata: 'lastModifiedAtTime' because on import we want to set this
   * to whatever value it was, not the insert time.
   */
  lastUsage: bigint;
  /**
   * Which kind of thing is this search for? Searches of different types are
   * stored together and need to be filtered to the specific type.
   */
  type: SearchType;
  /**
   * MD5 hash of the query string. This is used to enforce uniqueness of
   * queries without using the whole long query string as a key.
   */
  qhash: Uint8Array;
  /**
   * The profile ID this search is associated with.
   */
  profileId: bigint;
  /**
   * The Destiny version this search is associated with.
   */
  destinyVersion: number;
};

/**
 * Describes the message stately.generated.Search.
 * Use `create(SearchSchema)` to create a new message.
 */
export declare const SearchSchema: GenMessage<Search>;

/**
 * These items can be accessed via the following key paths:
 *   * /member-:memberId/settings
 */
export declare type Settings = ProtobufESMessage<'stately.generated.stately.Settings'> & {
  memberId: bigint;
  /**
   * Show item quality percentages
   */
  itemQuality: boolean;
  /**
   * Show new items with an overlay
   */
  showNewItems: boolean;
  /**
   * Sort characters (mostRecent, mostRecentReverse, fixed)
   */
  characterOrder: CharacterOrder;
  /**
   * Custom sorting properties, in order of application
   */
  itemSortOrderCustom: string[];
  /**
   * supplements itemSortOrderCustom by allowing each sort to be reversed
   */
  itemSortReversals: string[];
  /**
   * How many columns to display character buckets
   */
  charCol: number;
  /**
   * How many columns to display character buckets on Mobile
   */
  charColMobile: number;
  /**
   * How big in pixels to draw items - start smaller for iPad
   */
  itemSize: number;
  /**
   * Which categories or buckets should be collapsed?
   */
  collapsedSections: CollapsedSection[];
  /**
   * Hide triumphs once they're completed
   */
  completedRecordsHidden: boolean;
  /**
   * Hide show triumphs the manifest recommends be redacted
   */
  redactedRecordsRevealed: boolean;
  /**
   * Whether to keep one slot per item type open
   */
  farmingMakeRoomForItems: boolean;
  /**
   * How many spaces to clear when using Farming Mode (make space).
   */
  inventoryClearSpaces: number;
  /**
   * Hide completed triumphs/collections
   */
  hideCompletedRecords: boolean;
  /**
   * Custom character sort - across all accounts and characters! The values are character IDs.
   */
  customCharacterSort: string[];
  /**
   * The last direction the infusion fuel finder was set to.
   */
  infusionDirection: InfuseDirection;
  /**
   * The user's preferred language code.
   */
  language: string;
  /**
   * External sources for wish lists.
   * Expected to be a valid URL.
   * initialState should hold the current location of a reasonably-useful collection of rolls.
   * Set to empty string to not use wishListSource.
   */
  wishListSources: string[];
  /**
   * The last used settings for the Loadout Optimizer. These apply to all classes.
   */
  loParameters?: LoadoutParameters;
  /**
   * Stat order, enablement, etc. Stored per class.
   */
  loStatConstraintsByClass: StatConstraintsEntry[];
  /**
   * list of stat hashes of interest, keyed by class enum
   */
  customTotalStatsByClass: CustomStatsEntry[];
  /**
   * Selected columns for the Vault Organizer
   */
  organizerColumnsWeapons: string[];
  organizerColumnsArmor: string[];
  organizerColumnsGhost: string[];
  /**
   * Compare base stats or actual stats in Compare
   */
  compareBaseStats: boolean;
  /**
   * Item popup sidecar collapsed just shows icon and no character locations
   */
  sidecarCollapsed: boolean;
  /**
   * In "Single Character Mode" DIM pretends you only have one (active) character and all the other characters' items are in the vault.
   */
  singleCharacter: boolean;
  /**
   * Badge the app icon with the number of postmaster items on the current character
   */
  badgePostmaster: boolean;
  /**
   * Display perks as a list instead of a grid.
   */
  perkList: boolean;
  /**
   * How the loadouts menu and page should be sorted
   */
  loadoutSort: LoadoutSort;
  /**
   * Hide tagged items in the Item Feed
   */
  itemFeedHideTagged: boolean;
  /**
   * Show the Item Feed
   */
  itemFeedExpanded: boolean;
  /**
   * Pull from postmaster is an irreversible action and some people don't want to accidentally hit it.
   */
  hidePullFromPostmaster: boolean;
  /**
   * Select descriptions to display
   */
  descriptionsToDisplay: DescriptionOptions;
  /**
   * Plug the T10 masterwork into D2Y2+ random roll weapons for comparison purposes.
   */
  compareWeaponMasterwork: boolean;
  /**
   * Cutoff point; the instance ID of the newest item that isn't shown in
   * the item feed anymore after the user presses the "clear" button.
   */
  itemFeedWatermark: bigint;
  /**
   * a set of user-defined custom stat totals.
   * this will supersede customTotalStatsByClass.
   * it defaults below to empty, which in DIM, initiates fallback to customTotalStatsByClass
   */
  customStats: CustomStatDef[];
  /**
   * Automatically sync lock status with tag
   */
  autoLockTagged: boolean;
  /**
   * The currently chosen theme.
   */
  theme: string;
  /**
   * Whether to sort triumphs on the records tab by their progression percentage.
   */
  sortRecordProgression: boolean;
  /**
   * Whether to hide items that cost silver from the Vendors screen.
   */
  vendorsHideSilverItems: boolean;
  /**
   * An additional layer of grouping for weapons in the vault.
   */
  vaultWeaponGrouping: string;
  /**
   * How grouped weapons in the vault should be displayed.
   */
  vaultWeaponGroupingStyle: VaultWeaponGroupingStyle;
  /**
   * The currently selected item popup tab.
   */
  itemPopupTab: ItemPopupTab;
  /**
   * How grouped armor in the vault should be displayed.
   */
  vaultArmorGroupingStyle: VaultWeaponGroupingStyle;
};

/**
 * Describes the message stately.generated.Settings.
 * Use `create(SettingsSchema)` to create a new message.
 */
export declare const SettingsSchema: GenMessage<Settings>;

/**
 * Triumph stores a single record hash for a tracked triumph. Users can have any
 * number of tracked triumphs, with one item per triumph.
 *
 * These items can be accessed via the following key paths:
 *   * /p-:profileId/d-:destinyVersion/triumph-:recordHash
 */
export declare type Triumph = ProtobufESMessage<'stately.generated.stately.Triumph'> & {
  recordHash: number;
  profileId: bigint;
  destinyVersion: number;
};

/**
 * Describes the message stately.generated.Triumph.
 * Use `create(TriumphSchema)` to create a new message.
 */
export declare const TriumphSchema: GenMessage<Triumph>;
export declare type ArtifactUnlocks =
  ProtobufESMessage<'stately.generated.stately.ArtifactUnlocks'> & {
    /**
     * The item hashes of the unlocked artifact perk items.
     */
    unlockedItemHashes: number[];
    /**
     * The season this set of artifact unlocks was chosen from.
     */
    seasonNumber: number;
  };

/**
 * Describes the message stately.generated.ArtifactUnlocks.
 * Use `create(ArtifactUnlocksSchema)` to create a new message.
 */
export declare const ArtifactUnlocksSchema: GenMessage<ArtifactUnlocks>;
export declare type CollapsedSection =
  ProtobufESMessage<'stately.generated.stately.CollapsedSection'> & {
    key: string;
    /**
     * Whether this section is collapsed
     */
    collapsed: boolean;
  };

/**
 * Describes the message stately.generated.CollapsedSection.
 * Use `create(CollapsedSectionSchema)` to create a new message.
 */
export declare const CollapsedSectionSchema: GenMessage<CollapsedSection>;
export declare type CustomStatDef = ProtobufESMessage<'stately.generated.stately.CustomStatDef'> & {
  /**
   * a unique-per-user fake statHash used to look this stat up
   */
  statHash: number;
  /**
   * a unique-per-class name for this stat
   */
  label: string;
  /**
   * an abbreviated/crunched form of the stat label, for use in search filters
   */
  shortLabel: string;
  /**
   * which guardian class this stat should be used for. DestinyClass.Unknown makes a global (all 3 classes) stat
   */
  class: DestinyClass;
  /**
   * info about how to calculate the stat total
   */
  weights: CustomStatWeightsEntry[];
};

/**
 * Describes the message stately.generated.CustomStatDef.
 * Use `create(CustomStatDefSchema)` to create a new message.
 */
export declare const CustomStatDefSchema: GenMessage<CustomStatDef>;
export declare type CustomStatsEntry =
  ProtobufESMessage<'stately.generated.stately.CustomStatsEntry'> & {
    classType: DestinyClass;
    customStats: number[];
  };

/**
 * Describes the message stately.generated.CustomStatsEntry.
 * Use `create(CustomStatsEntrySchema)` to create a new message.
 */
export declare const CustomStatsEntrySchema: GenMessage<CustomStatsEntry>;
/**
 * traditional custom stats use a binary 1 or 0 for all 6 armor stats, but this could support more complex weights
 */
export declare type CustomStatWeightsEntry =
  ProtobufESMessage<'stately.generated.stately.CustomStatWeightsEntry'> & {
    statHash: number;
    weight: number;
  };

/**
 * Describes the message stately.generated.CustomStatWeightsEntry.
 * Use `create(CustomStatWeightsEntrySchema)` to create a new message.
 */
export declare const CustomStatWeightsEntrySchema: GenMessage<CustomStatWeightsEntry>;
/**
 * normally found inside DestinyLoadoutComponent, mapped to respective definition tables
 */
export declare type InGameLoadoutIdentifiers =
  ProtobufESMessage<'stately.generated.stately.InGameLoadoutIdentifiers'> & {
    colorHash: number;
    iconHash: number;
    nameHash: number;
  };

/**
 * Describes the message stately.generated.InGameLoadoutIdentifiers.
 * Use `create(InGameLoadoutIdentifiersSchema)` to create a new message.
 */
export declare const InGameLoadoutIdentifiersSchema: GenMessage<InGameLoadoutIdentifiers>;
export declare type LoadoutItem = ProtobufESMessage<'stately.generated.stately.LoadoutItem'> & {
  /**
   * itemInstanceId of the item (if it's instanced). Default to zero for an uninstanced item or unknown ID.
   */
  id: bigint;
  /**
   * DestinyInventoryItemDefinition hash of the item
   */
  hash: number;
  /**
   * Optional amount (for consumables), default to zero
   */
  amount: number;
  /**
   * The socket overrides for the item. These signal what DestinyInventoryItemDefinition
   * (by it's hash) is supposed to be socketed into the given socket index.
   */
  socketOverrides: SocketOverride[];
  /**
   * UTC epoch seconds timestamp of when the item was crafted. Used to
   * match up items that have changed instance ID from being reshaped since they
   * were added to the loadout.
   */
  craftedDate: bigint;
};

/**
 * Describes the message stately.generated.LoadoutItem.
 * Use `create(LoadoutItemSchema)` to create a new message.
 */
export declare const LoadoutItemSchema: GenMessage<LoadoutItem>;
/**
 * Parameters that explain how this loadout was chosen (in Loadout Optimizer)
 * and at the same time, how this loadout should be configured when equipped.
 * This can be used to re-load a loadout into Loadout Optimizer with its
 * settings intact, or to equip the right mods when applying a loadout if AWA is
 * ever released.
 *
 * Originally this was meant to model parameters independent of specific items,
 * as a means of sharing Loadout Optimizer settings between users, but now we
 * just share whole loadouts, so this can be used for any sort of parameter we
 * want to add to loadouts.
 *
 * All properties are optional, but most have defaults specified in
 * defaultLoadoutParameters that should be used if they are undefined.
 */
export declare type LoadoutParameters =
  ProtobufESMessage<'stately.generated.stately.LoadoutParameters'> & {
    /**
     * The stats the user cared about for this loadout, in the order they cared about them and
     * with optional range by tier. If a stat is "ignored" it should just be missing from this
     * list.
     */
    statConstraints: StatConstraint[];
    /**
     * The mods that will be used with this loadout. Each entry is an inventory
     * item hash representing the mod item. Hashes may appear multiple times.
     * These are not associated with any specific item in the loadout - when
     * applying the loadout we should automatically determine the minimum of
     * changes required to match the desired mods, and apply these mods to the
     * equipped items.
     */
    mods: number[];
    /**
     * If set, after applying the mods above, all other mods will be removed from armor.
     */
    clearMods: boolean;
    /**
     * Whether to clear out other weapons when applying this loadout
     */
    clearWeapons: boolean;
    /**
     * Whether to clear out other weapons when applying this loadout
     */
    clearArmor: boolean;
    /**
     * Mods that must be applied to a specific bucket hash. In general, prefer to
     * use the flat mods list above, and rely on the loadout function to assign
     * mods automatically. However there are some mods like shaders which can't
     * be automatically assigned to the right piece. These only apply to the equipped
     * item.
     */
    modsByBucket: ModsByBucketEntry[];
    /**
     * The artifact unlocks relevant to this build.
     */
    artifactUnlocks?: ArtifactUnlocks;
    /**
     * Whether to automatically add stat mods.
     */
    autoStatMods: boolean;
    /**
     * A search filter applied while editing the loadout in Loadout Optimizer,
     * which constrains the items that can be in the loadout.
     */
    query: string;
    /**
     * Whether armor of this type will have assumed masterwork stats in the Loadout Optimizer.
     */
    assumeArmorMasterwork: AssumeArmorMasterwork;
    /**
     * The InventoryItemHash of the pinned exotic, if any was chosen.
     */
    exoticArmorHash: bigint;
    /**
     * a user may optionally specify which icon/color/name will be used,
     * if this DIM loadout is saved to an in-game slot.
     */
    inGameIdentifiers?: InGameLoadoutIdentifiers;
    /**
     * When calculating loadout stats, should "Font of ..." mods be assumed active
     * and their runtime bonus stats be included?
     */
    includeRuntimeStatBenefits: boolean;
    /**
     * A list of armor perks that should be included in this loadout. This
     * expresses a desire in the Loadout Optimizer to generate sets that have
     * these perks.
     *
     *  For regular perks each occurrence of the perk in this list represents one
     * instance of the perk that should appear on an item in the loadout. For
     * armor set bonuses, use setBonuses instead.
     *
     * For example, this can be used to:
     * - Specify what exotic class item perks you want
     * - Specify that you want some seasonal armor perks to be used (e.g. 3
     *   instances of Iron Lord's Pride)
     *
     *  For picking specific perks on weapons, use modsByBucket instead.
     */
    perks: number[];
    /**
     * The set bonuses that we want to activate with this loadout. This is a
     * mapping of one or more DestinyEquipableItemSetDefinition hashes to the
     * number of pieces we require that provide that setBonus.
     */
    setBonuses: SetBonusCount[];
  };

/**
 * Describes the message stately.generated.LoadoutParameters.
 * Use `create(LoadoutParametersSchema)` to create a new message.
 */
export declare const LoadoutParametersSchema: GenMessage<LoadoutParameters>;
export declare type ModsByBucketEntry =
  ProtobufESMessage<'stately.generated.stately.ModsByBucketEntry'> & {
    bucketHash: number;
    modHashes: number[];
  };

/**
 * Describes the message stately.generated.ModsByBucketEntry.
 * Use `create(ModsByBucketEntrySchema)` to create a new message.
 */
export declare const ModsByBucketEntrySchema: GenMessage<ModsByBucketEntry>;
export declare type SetBonusCount = ProtobufESMessage<'stately.generated.stately.SetBonusCount'> & {
  /**
   * The DestinyEquipableItemSetDefinition hash of the set bonus
   */
  setBonusHash: number;
  /**
   * The number of pieces we require that provide that setBonus
   */
  count: number;
};

/**
 * Describes the message stately.generated.SetBonusCount.
 * Use `create(SetBonusCountSchema)` to create a new message.
 */
export declare const SetBonusCountSchema: GenMessage<SetBonusCount>;
export declare type SocketOverride =
  ProtobufESMessage<'stately.generated.stately.SocketOverride'> & {
    /**
     * The index of the socket in the item
     */
    socketIndex: number;
    /**
     * The hash of the item that should be in this socket
     */
    itemHash: number;
  };

/**
 * Describes the message stately.generated.SocketOverride.
 * Use `create(SocketOverrideSchema)` to create a new message.
 */
export declare const SocketOverrideSchema: GenMessage<SocketOverride>;
/**
 * A constraint on the values an armor stat can take
 */
export declare type StatConstraint =
  ProtobufESMessage<'stately.generated.stately.StatConstraint'> & {
    /**
     * The stat definition hash of the stat
     */
    statHash: number;
    /**
     * The minimum tier value for the stat. 0 if unset.
     */
    minTier: number;
    /**
     * The maximum tier value for the stat. 10 if unset.
     */
    maxTier: number;
    /**
     * Minimum absolute value for the stat. 0 if unset. Replaces minTier in Edge of Fate.
     */
    minStat: number;
    /**
     * Maximum absolute value for the stat. Max Possible Stat Value if unset. Replaces maxTier in Edge of Fate.
     */
    maxStat: number;
  };

/**
 * Describes the message stately.generated.StatConstraint.
 * Use `create(StatConstraintSchema)` to create a new message.
 */
export declare const StatConstraintSchema: GenMessage<StatConstraint>;
export declare type StatConstraintsEntry =
  ProtobufESMessage<'stately.generated.stately.StatConstraintsEntry'> & {
    classType: DestinyClass;
    constraints: StatConstraint[];
  };

/**
 * Describes the message stately.generated.StatConstraintsEntry.
 * Use `create(StatConstraintsEntrySchema)` to create a new message.
 */
export declare const StatConstraintsEntrySchema: GenMessage<StatConstraintsEntry>;

/**
 * Whether armor of this type will have assumed masterworked stats in the Loadout Optimizer.
 */
export enum AssumeArmorMasterwork {
  /**
   * No armor will have assumed masterworked stats.
   */
  AssumeArmorMasterwork_None = 0,
  /**
   * Only legendary armor will have assumed masterworked stats.
   */
  AssumeArmorMasterwork_Legendary = 1,
  /**
   * All armor (legendary & exotic) will have assumed masterworked stats.
   */
  AssumeArmorMasterwork_All = 2,
  /**
   * All armor (legendary & exotic) will have assumed masterworked stats, and Exotic Armor will be upgraded to have an artifice mod slot.
   */
  AssumeArmorMasterwork_ArtificeExotic = 3,
}

/**
 * Describes the enum stately.generated.AssumeArmorMasterwork.
 */
export declare const AssumeArmorMasterworkSchema: GenEnum<AssumeArmorMasterwork>;

export enum CharacterOrder {
  /**
   * The zero value for CharacterOrder, used when it is not set to any other value.
   */
  CharacterOrder_UNSPECIFIED = 0,
  CharacterOrder_mostRecent = 1,
  CharacterOrder_mostRecentReverse = 2,
  CharacterOrder_fixed = 3,
  CharacterOrder_custom = 4,
}

/**
 * Describes the enum stately.generated.CharacterOrder.
 */
export declare const CharacterOrderSchema: GenEnum<CharacterOrder>;

export enum DescriptionOptions {
  /**
   * The zero value for DescriptionOptions, used when it is not set to any other value.
   */
  DescriptionOptions_UNSPECIFIED = 0,
  DescriptionOptions_bungie = 1,
  DescriptionOptions_community = 2,
  DescriptionOptions_both = 3,
}

/**
 * Describes the enum stately.generated.DescriptionOptions.
 */
export declare const DescriptionOptionsSchema: GenEnum<DescriptionOptions>;

export enum DestinyClass {
  DestinyClass_Titan = 0,
  DestinyClass_Hunter = 1,
  DestinyClass_Warlock = 2,
  DestinyClass_Unknown = 3,
}

/**
 * Describes the enum stately.generated.DestinyClass.
 */
export declare const DestinyClassSchema: GenEnum<DestinyClass>;

export enum InfuseDirection {
  /**
   * The zero value for InfuseDirection, used when it is not set to any other value.
   */
  InfuseDirection_UNSPECIFIED = 0,
  /**
   * infuse something into the query (query = target)
   */
  InfuseDirection_Infuse = 1,
  /**
   * infuse the query into the target (query = source)
   */
  InfuseDirection_Fuel = 2,
}

/**
 * Describes the enum stately.generated.InfuseDirection.
 */
export declare const InfuseDirectionSchema: GenEnum<InfuseDirection>;

export enum ItemPopupTab {
  ItemPopupTab_Overview = 0,
  ItemPopupTab_Triage = 1,
}

/**
 * Describes the enum stately.generated.ItemPopupTab.
 */
export declare const ItemPopupTabSchema: GenEnum<ItemPopupTab>;

/**
 * How the loadouts menu and page should be sorted
 */
export enum LoadoutSort {
  LoadoutSort_ByEditTime = 0,
  LoadoutSort_ByName = 1,
}

/**
 * Describes the enum stately.generated.LoadoutSort.
 */
export declare const LoadoutSortSchema: GenEnum<LoadoutSort>;

export enum SearchType {
  SearchType_Item = 0,
  SearchType_Loadout = 1,
}

/**
 * Describes the enum stately.generated.SearchType.
 */
export declare const SearchTypeSchema: GenEnum<SearchType>;

export enum TagValue {
  /**
   * The zero value for TagValue, used when it is not set to any other value.
   */
  TagValue_UNSPECIFIED = 0,
  TagValue_favorite = 1,
  TagValue_keep = 2,
  TagValue_infuse = 3,
  TagValue_junk = 4,
  TagValue_archive = 5,
}

/**
 * Describes the enum stately.generated.TagValue.
 */
export declare const TagValueSchema: GenEnum<TagValue>;

export enum VaultWeaponGroupingStyle {
  VaultWeaponGroupingStyle_Lines = 0,
  VaultWeaponGroupingStyle_Inline = 1,
}

/**
 * Describes the enum stately.generated.VaultWeaponGroupingStyle.
 */
export declare const VaultWeaponGroupingStyleSchema: GenEnum<VaultWeaponGroupingStyle>;
