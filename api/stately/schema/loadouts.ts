import {
  arrayOf,
  bool,
  enumType,
  Fields,
  itemType,
  migrate,
  objectType,
  string,
  timestampMilliseconds,
  timestampSeconds,
  uint32,
  uuid,
} from '@stately-cloud/schema';
import {
  DestinyClass,
  DestinyVersion,
  HashID,
  ItemID,
  LockedExoticHash,
  ProfileID,
} from './types.js';

export const SocketOverride = objectType('SocketOverride', {
  fields: {
    /** The index of the socket in the item */
    socketIndex: { type: uint32, required: false },
    /** The hash of the item that should be in this socket */
    itemHash: { type: HashID },
  },
});

export const LoadoutItem = objectType('LoadoutItem', {
  fields: {
    /** itemInstanceId of the item (if it's instanced). Default to zero for an uninstanced item or unknown ID. */
    id: { type: ItemID, required: false },
    /** DestinyInventoryItemDefinition hash of the item */
    hash: { type: HashID },
    /** Optional amount (for consumables), default to zero */
    amount: { type: uint32, required: false },
    /**
     * The socket overrides for the item. These signal what DestinyInventoryItemDefinition
     * (by it's hash) is supposed to be socketed into the given socket index.
     */
    socketOverrides: { type: arrayOf(SocketOverride), required: false },
    /**
     * UTC epoch seconds timestamp of when the item was crafted. Used to
     * match up items that have changed instance ID from being reshaped since they
     * were added to the loadout.
     */
    craftedDate: { type: timestampSeconds, required: false },
  },
});

/** normally found inside DestinyLoadoutComponent, mapped to respective definition tables */
export const InGameLoadoutIdentifiers = objectType('InGameLoadoutIdentifiers', {
  fields: {
    colorHash: { type: HashID },
    iconHash: { type: HashID },
    nameHash: { type: HashID },
  },
});

// These are reused in LoadoutShare
export const loadoutFields: Fields = {
  /** Name/title for the loadout. */
  name: { type: string },
  /** Optional longform notes about the loadout. */
  notes: { type: string, required: false },
  /**
   * DestinyClass enum value for the class this loadout is restricted
   * to. This is optional (set to Unknown for loadouts that can be used anywhere).
   */
  classType: { type: DestinyClass, required: false },
  /** List of equipped items in the loadout */
  equipped: { type: arrayOf(LoadoutItem), required: false },
  /** List of unequipped items in the loadout */
  unequipped: { type: arrayOf(LoadoutItem), required: false },
  /** Information about the desired properties of this loadout - used to drive the Loadout Optimizer or apply Mod Loadouts */
  parameters: { type: LoadoutParameters, required: false },

  /** When was this Loadout initially created? Tracked automatically by the API - when saving a loadout this field is ignored. */
  createdAt: { type: timestampMilliseconds, fromMetadata: 'createdAtTime' },
  /** When was this Loadout last changed? Tracked automatically by the API - when saving a loadout this field is ignored. */
  lastUpdatedAt: { type: timestampMilliseconds, fromMetadata: 'lastModifiedAtTime' },

  destinyVersion: { type: DestinyVersion },
  profileId: { type: ProfileID },
};

export const Loadout = itemType('Loadout', {
  keyPath: [
    // We put this under a profile and a destiny version so we can get all
    // loadouts for a particular destiny version in one query.
    '/p-:profileId/d-:destinyVersion/loadout-:id',
    // Technically loadouts are meant to be globally unique by ID, and we could
    // add this alias to enforce that. But it doesn't seem too important since
    // we never actually need to operate on them by ID.
    // '/loadout-:id'
  ],
  fields: {
    /**
     * A globally unique (UUID) identifier for the loadout. Chosen by the client, not autogenerated by the DB.
     */
    id: { type: uuid },
    ...loadoutFields,
  },
});

/** Whether armor of this type will have assumed masterworked stats in the Loadout Optimizer. */
export function AssumeArmorMasterwork() {
  return enumType('AssumeArmorMasterwork', {
    /** No armor will have assumed masterworked stats. */
    None: 0,
    /** Only legendary armor will have assumed masterworked stats. */
    Legendary: 1,
    /** All armor (legendary & exotic) will have assumed masterworked stats. */
    All: 2,
    /** All armor (legendary & exotic) will have assumed masterworked stats, and Exotic Armor will be upgraded to have an artifice mod slot. */
    ArtificeExotic: 3,
  });
}

/** How the loadouts menu and page should be sorted */
export const LoadoutSort = enumType('LoadoutSort', {
  ByEditTime: 0,
  ByName: 1,
});

export function ModsByBucketEntry() {
  return objectType('ModsByBucketEntry', {
    fields: {
      bucketHash: { type: HashID },
      modHashes: { type: arrayOf(HashID), required: false },
    },
  });
}

export function ArtifactUnlocks() {
  return objectType('ArtifactUnlocks', {
    fields: {
      /** The item hashes of the unlocked artifact perk items. */
      unlockedItemHashes: { type: arrayOf(HashID), required: false },
      /** The season this set of artifact unlocks was chosen from. */
      seasonNumber: { type: uint32 },
    },
  });
}

/**
 * Parameters that explain how this loadout was chosen (in Loadout Optimizer)
 * and at the same time, how this loadout should be configured when equipped.
 * This can be used to re-load a loadout into Loadout Optimizer with its
 * settings intact, or to equip the right mods when applying a loadout if AWA is
 * ever released.
 *
 * Originally this was meant to model parameters independent of specific items,
 * as a means of sharing Loadout Optimizer settings between users, but now we
 * just share whole loadouts, so this can be used for any sort of parameter we
 * want to add to loadouts.
 *
 * All properties are optional, but most have defaults specified in
 * defaultLoadoutParameters that should be used if they are undefined.
 */
export function LoadoutParameters() {
  return objectType('LoadoutParameters', {
    fields: {
      /**
       * The stats the user cared about for this loadout, in the order they cared about them and
       * with optional range by tier. If a stat is "ignored" it should just be missing from this
       * list.
       */
      statConstraints: { type: arrayOf(StatConstraint), required: false },

      /**
       * The mods that will be used with this loadout. Each entry is an inventory
       * item hash representing the mod item. Hashes may appear multiple times.
       * These are not associated with any specific item in the loadout - when
       * applying the loadout we should automatically determine the minimum of
       * changes required to match the desired mods, and apply these mods to the
       * equipped items.
       */
      mods: { type: arrayOf(HashID), required: false },

      /**
       * A list of perks that should be activated by this loadout. This
       * expresses a desire in the Loadout Optimizer to generate sets that have
       * these perks.
       *
       * For "armor set perks" this indicates that the perk should be activated
       * by having enough set pieces to activate it. For regular perks, each
       * occurrence of the perk in this list represents one instance of the perk
       * that should appear on an item in the loadout.
       *
       * For example, this can be used to:
       * - Specify what exotic class item perks you want
       * - Specify set bonuses that you want to activate
       * - Specify that you want some seasonal armor perks to be used (e.g. 3
       *   instances of the Iron Banner experience perk)
       *
       *  For picking specific perks on weapons, use modsByBucket instead.
       */
      perks: { type: arrayOf(HashID), required: false },

      /**
       * If set, after applying the mods above, all other mods will be removed from armor.
       */
      clearMods: { type: bool },

      /** Whether to clear out other weapons when applying this loadout */
      clearWeapons: { type: bool },

      /** Whether to clear out other weapons when applying this loadout */
      clearArmor: { type: bool },

      /**
       * Mods that must be applied to a specific bucket hash. In general, prefer to
       * use the flat mods list above, and rely on the loadout function to assign
       * mods automatically. However there are some mods like shaders which can't
       * be automatically assigned to the right piece. These only apply to the equipped
       * item.
       */
      modsByBucket: { type: arrayOf(ModsByBucketEntry), required: false },

      /** The artifact unlocks relevant to this build. */
      artifactUnlocks: { type: ArtifactUnlocks, required: false },

      /** Whether to automatically add stat mods. */
      autoStatMods: { type: bool },

      /**
       * A search filter applied while editing the loadout in Loadout Optimizer,
       * which constrains the items that can be in the loadout.
       */
      query: { type: string, required: false },

      /**
       * Whether armor of this type will have assumed masterwork stats in the Loadout Optimizer.
       */
      assumeArmorMasterwork: { type: AssumeArmorMasterwork, required: false },

      /**
       * The InventoryItemHash of the pinned exotic, if any was chosen.
       */
      exoticArmorHash: { type: LockedExoticHash, required: false },

      /**
       * a user may optionally specify which icon/color/name will be used,
       * if this DIM loadout is saved to an in-game slot.
       */
      inGameIdentifiers: { type: InGameLoadoutIdentifiers, required: false },

      /**
       * When calculating loadout stats, should "Font of ..." mods be assumed active
       * and their runtime bonus stats be included?
       */
      includeRuntimeStatBenefits: { type: bool },
    },
  });
}

/** A constraint on the values an armor stat can take */
export function StatConstraint() {
  return objectType('StatConstraint', {
    fields: {
      /** The stat definition hash of the stat */
      statHash: { type: HashID },
      /** The minimum tier value for the stat. 0 if unset. */
      minTier: { type: uint32, required: false, valid: 'this <= 10 && this >= 0' },
      /** The maximum tier value for the stat. 10 if unset. */
      maxTier: { type: uint32, required: false, valid: 'this <= 10 && this >= 0' },
      /** Minimum absolute value for the stat. 0 if unset. Replaces minTier in Edge of Fate. */
      minStat: { type: uint32, required: false, valid: 'this <= 200 && this >= 0' },
      /** Maximum absolute value for the stat. Max Possible Stat Value if unset. Replaces maxTier in Edge of Fate. */
      maxStat: { type: uint32, required: false, valid: 'this <= 200 && this >= 0' },
    },
  });
}

migrate(3, 'Add new Loadout fields', (t) => {
  t.changeType(StatConstraint, (m) => {
    m.addField('maxStat');
    m.addField('minStat');
  });
  t.changeType(LoadoutParameters, (m) => {
    m.addField('perks');
  });
});
