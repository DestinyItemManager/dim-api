import {
  bool,
  bytes,
  enumType,
  itemType,
  string,
  timestampMilliseconds,
} from '@stately-cloud/schema';
import { DestinyVersion, ProfileID, uint32 } from './types.js';

export const SearchType = enumType('SearchType', { Item: 0, Loadout: 1 });

/**
 * A search query. This can either be from history (recent searches), pinned (saved searches), or suggested.
 */
export const Search = itemType('Search', {
  // We put this under a profile and a destiny version so we can get all search
  // history for a particular destiny version in one query (along with other
  // stuff in the profile). Technically the searches could be shared between
  // profiles, but if we did that we'd need more queries.
  keyPath: '/p-:profileId/d-:destinyVersion/search-:qhash',
  // TODO: enable last usage index
  // indexes: [
  //   {
  //     groupLocalIndex: 1,
  //     field: 'lastUsage',
  //   },
  // ],
  fields: {
    /**
     * The full search query. These are
     */
    query: { type: string, fieldNum: 1 },
    /** A zero usage count means this is a suggested/preloaded search. */
    usageCount: { type: uint32, fieldNum: 2, required: false },
    /** Has this search been saved/favorite'd/pinned by the user? */
    saved: { type: bool, fieldNum: 3 },
    /**
     * The last time this was used, as a unix millisecond timestamp. We don't
     * use fromMetadata: 'lastModifiedAtTime' because on import we want to set this
     * to whatever value it was, not the insert time.
     */
    lastUsage: { type: timestampMilliseconds, fieldNum: 4 },
    /**
     * Which kind of thing is this search for? Searches of different types are
     * stored together and need to be filtered to the specific type.
     */
    type: { type: SearchType, fieldNum: 5, required: false },

    /**
     * MD5 hash of the query string. This is used to enforce uniqueness of
     * queries without using the whole long query string as a key.
     */
    // TODO: in the current postgres schema, queries are stored as a hash of the
    // query string which is automatically generated by the DB. We'd have to do
    // it manually.
    qhash: { type: bytes, fieldNum: 6 /* expression: 'md5(this.query)' */ },

    /** The profile ID this search is associated with. */
    profileId: { type: ProfileID, fieldNum: 7 },

    /** The Destiny version this search is associated with. */
    destinyVersion: { type: DestinyVersion, fieldNum: 8 },
  },
});
